<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="nova的构成openstac由不同的组件构成，目前常用的组件有nova,cinder,glance,neutron等。组件之间采用restful-api进行通信，组件内部使用RPC进行通讯。 每个组件内部又分为不同的模块，以nova为例，可以分出的模块如下：  nova api nova compute nova schedule nova condutor  nova的内部的基本流程如果我向n">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/11/06/openstack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="nova的构成openstac由不同的组件构成，目前常用的组件有nova,cinder,glance,neutron等。组件之间采用restful-api进行通信，组件内部使用RPC进行通讯。 每个组件内部又分为不同的模块，以nova为例，可以分出的模块如下：  nova api nova compute nova schedule nova condutor  nova的内部的基本流程如果我向n">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-11-06T13:33:45.343Z">
<meta property="article:modified_time" content="2023-11-06T13:33:45.343Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-openstack源码阅读(一)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/06/openstack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)/" class="article-date">
  <time class="dt-published" datetime="2023-11-06T13:33:45.343Z" itemprop="datePublished">2023-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="nova的构成"><a href="#nova的构成" class="headerlink" title="nova的构成"></a>nova的构成</h3><p>openstac由不同的组件构成，目前常用的组件有nova,cinder,glance,neutron等。组件之间采用restful-api进行通信，组件内部使用RPC进行通讯。</p>
<p>每个组件内部又分为不同的模块，以nova为例，可以分出的模块如下：</p>
<ul>
<li>nova api</li>
<li>nova compute</li>
<li>nova schedule</li>
<li>nova condutor</li>
</ul>
<h3 id="nova的内部的基本流程"><a href="#nova的内部的基本流程" class="headerlink" title="nova的内部的基本流程"></a>nova的内部的基本流程</h3><p>如果我向nova发送了一个create server的restful请求，nova内部会如何处理这个请求呢？大致的流程概括如下。</p>
<ol>
<li>nova api接受到请求，做出相应的校验，参数处理和资源准备，然后rpc调用nova-schduler</li>
<li>nova scheduler是虚拟机调度服务，选择合适的计算节点运行虚拟机，然后rpc调用nova-compute</li>
<li>nova compute是虚拟机的管理服务，通过调用hypervisor api实现虚拟机的生命周期管理，以kvm为例，就是使用libvert的api进行虚拟机生命周期管理，在过程中会对conductor进行调用</li>
<li>nova conductor和数据库进行交互（之所以使用nova conductor而不是nova compute直接和数据库交互是出于安全性和可伸缩性考虑）</li>
</ol>
<p>每个组件是如何实现的，具体做了哪些事情，以及为什么要这么实现，后面会继续尝试进行分析。</p>
<h3 id="nova-api的实现"><a href="#nova-api的实现" class="headerlink" title="nova api的实现"></a>nova api的实现</h3><p>nova api使用paste_deploy来帮助生成wsgi app。要理解nova api的实现，首先要理解paste deploy的使用方式。</p>
<p>简单的概括一下paste deploy是做什么的。PasteDeploy是一套发现和配置WSGI应用的系统。它根据指定的配置文件动态生成入口点和组织WSGI applieation间的逻辑关系。换成一个比较容易理解的方式来说，就是使用配置文件生成wsgi app并将它们组装起来。</p>
<p>来看一个最小的deploy使用demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># config.ini</span><br><span class="line">[composite:main]</span><br><span class="line">use = call:urlmap:urlmap_factory</span><br><span class="line">/v1: router_v1 </span><br><span class="line"></span><br><span class="line">[composite:router_v1]</span><br><span class="line">use = call:router_v1:app_factory</span><br><span class="line">r1 = filter_v1 app_v1</span><br><span class="line"></span><br><span class="line">[filter:filter_v1]</span><br><span class="line">paste.filter_factory = filter_v1:filter_factory</span><br><span class="line"></span><br><span class="line">[app:app_v1]</span><br><span class="line">paste.app_factory = app_v1:app_factory</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># router_v1</span></span><br><span class="line"><span class="keyword">from</span> webob.dec <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> webob.exc</span><br><span class="line"><span class="keyword">from</span> routes <span class="keyword">import</span> Mapper, middleware</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_load_pipeline</span>(<span class="params">loader, pipeline</span>):</span><br><span class="line">    filters = [loader.get_filter(n) <span class="keyword">for</span> n <span class="keyword">in</span> pipeline[:-<span class="number">1</span>]]</span><br><span class="line">    app = loader.get_app(pipeline[-<span class="number">1</span>])</span><br><span class="line">    filters.reverse()</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">filter</span> <span class="keyword">in</span> filters:</span><br><span class="line">        app = <span class="built_in">filter</span>(app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_factory</span>(<span class="params">loader, global_conf, **local_conf</span>):</span><br><span class="line">    pipeline = local_conf[<span class="string">&#x27;r1&#x27;</span>]</span><br><span class="line">    pipeline = pipeline.split()</span><br><span class="line">    <span class="keyword">return</span> _load_pipeline(loader, pipeline)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># filter_v1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_str</span>(<span class="params">app</span>):</span><br><span class="line">    <span class="keyword">return</span> app + <span class="string">&quot;filter v1&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter_factory</span>(<span class="params">loader, **local_config</span>):</span><br><span class="line">    <span class="keyword">return</span> add_str</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app_v1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_factory</span>(<span class="params">loader, **local_config</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;app v1&quot;</span></span><br></pre></td></tr></table></figure>


<p>从以上代码可以看到一个基本paste deploy的使用方式</p>
<ul>
<li>loadapp从配置文件中加载一个wsgi app</li>
<li>可以通过paste deploy传入的loader获取到不同的组件</li>
<li>将最终需要返回的app作为参数传入pipeline并经过层层处理</li>
</ul>
<p>对比nova api的实际配置文件如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nova/etc/nova</span></span><br><span class="line"><span class="section">[composite:osapi_compute]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.openstack.urlmap:urlmap_factory</span><br><span class="line">/: oscomputeversions</span><br><span class="line">/v2: openstack_compute_api_v21_legacy_v2_compatible</span><br><span class="line">/v2.1: openstack_compute_api_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[composite:openstack_compute_api_v21]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.auth:pipeline_factory_v21</span><br><span class="line"><span class="attr">noauth2</span> = cors compute_req_id faultwrap sizelimit osprofiler noauth2 osapi_compute_app_v21</span><br><span class="line"><span class="attr">keystone</span> = cors compute_req_id faultwrap sizelimit osprofiler authtoken keystonecontext osapi_compute_app_v21</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不难理解，nova api首先使用nova&#x2F;api&#x2F;openstack&#x2F;urlmap中的urlmap_factory函数根据版本对请求进行路由。路由的逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">urlmap_factory</span>(<span class="params">loader, global_conf, **local_conf</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;not_found_app&#x27;</span> <span class="keyword">in</span> local_conf:</span><br><span class="line">        not_found_app = local_conf.pop(<span class="string">&#x27;not_found_app&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        not_found_app = global_conf.get(<span class="string">&#x27;not_found_app&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> not_found_app:</span><br><span class="line">        not_found_app = loader.get_app(not_found_app, global_conf=global_conf)</span><br><span class="line">    urlmap = URLMap(not_found_app=not_found_app)</span><br><span class="line">    <span class="keyword">for</span> path, app_name <span class="keyword">in</span> local_conf.items():</span><br><span class="line">        path = paste.urlmap.parse_path_expression(path)</span><br><span class="line">        app = loader.get_app(app_name, global_conf=global_conf)</span><br><span class="line">        urlmap[path] = app</span><br><span class="line">    <span class="keyword">return</span> urlmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">URLMap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">        host = environ.get(<span class="string">&#x27;HTTP_HOST&#x27;</span>, environ.get(<span class="string">&#x27;SERVER_NAME&#x27;</span>)).lower()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;:&#x27;</span> <span class="keyword">in</span> host:</span><br><span class="line">            host, port = host.split(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> environ[<span class="string">&#x27;wsgi.url_scheme&#x27;</span>] == <span class="string">&#x27;http&#x27;</span>:</span><br><span class="line">                port = <span class="string">&#x27;80&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                port = <span class="string">&#x27;443&#x27;</span></span><br><span class="line"></span><br><span class="line">        path_info = environ[<span class="string">&#x27;PATH_INFO&#x27;</span>]</span><br><span class="line">        path_info = self.normalize_url(path_info, <span class="literal">False</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The MIME type for the response is determined in one of two ways:</span></span><br><span class="line">        <span class="comment"># 1) URL path suffix (eg /servers/detail.json)</span></span><br><span class="line">        <span class="comment"># 2) Accept header (eg application/json;q=0.8, application/xml;q=0.2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The API version is determined in one of three ways:</span></span><br><span class="line">        <span class="comment"># 1) URL path prefix (eg /v1.1/tenant/servers/detail)</span></span><br><span class="line">        <span class="comment"># 2) Content-Type header (eg application/json;version=1.1)</span></span><br><span class="line">        <span class="comment"># 3) Accept header (eg application/json;q=0.8;version=1.1)</span></span><br><span class="line"></span><br><span class="line">        supported_content_types = <span class="built_in">list</span>(wsgi.get_supported_content_types())</span><br><span class="line"></span><br><span class="line">        mime_type, app, app_url = self._path_strategy(host, port, path_info)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Accept application/atom+xml for the index query of each API</span></span><br><span class="line">        <span class="comment"># version mount point as well as the root index</span></span><br><span class="line">        <span class="keyword">if</span> (app_url <span class="keyword">and</span> app_url + <span class="string">&#x27;/&#x27;</span> == path_info) <span class="keyword">or</span> path_info == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            supported_content_types.append(<span class="string">&#x27;application/atom+xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> app:</span><br><span class="line">            app = self._content_type_strategy(host, port, environ)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mime_type <span class="keyword">or</span> <span class="keyword">not</span> app:</span><br><span class="line">            possible_mime_type, possible_app = self._accept_strategy(</span><br><span class="line">                    host, port, environ, supported_content_types)</span><br><span class="line">            <span class="keyword">if</span> possible_mime_type <span class="keyword">and</span> <span class="keyword">not</span> mime_type:</span><br><span class="line">                mime_type = possible_mime_type</span><br><span class="line">            <span class="keyword">if</span> possible_app <span class="keyword">and</span> <span class="keyword">not</span> app:</span><br><span class="line">                app = possible_app</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mime_type:</span><br><span class="line">            mime_type = <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> app:</span><br><span class="line">            <span class="comment"># Didn&#x27;t match a particular version, probably matches default</span></span><br><span class="line">            app, app_url = self._<span class="keyword">match</span>(host, port, path_info)</span><br><span class="line">            <span class="keyword">if</span> app:</span><br><span class="line">                app = self._munge_path(app, path_info, app_url)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> app:</span><br><span class="line">            environ[<span class="string">&#x27;nova.best_content_type&#x27;</span>] = mime_type</span><br><span class="line">            <span class="keyword">return</span> app(environ, start_response)</span><br><span class="line"></span><br><span class="line">        LOG.debug(<span class="string">&#x27;Could not find application for %s&#x27;</span>, environ[<span class="string">&#x27;PATH_INFO&#x27;</span>])</span><br><span class="line">        environ[<span class="string">&#x27;paste.urlmap_object&#x27;</span>] = self</span><br><span class="line">        <span class="keyword">return</span> self.not_found_application(environ, start_response)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上的URLMap只保留了__call__部分的代码，可以看出URLMap实现了根据不同的版本信息路由到不同的不同的组件中。假设使用的版本为v21，继续openstack_compute_api_v21实现了那些功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_load_pipeline</span>(<span class="params">loader, pipeline</span>):</span><br><span class="line">    filters = [loader.get_filter(n) <span class="keyword">for</span> n <span class="keyword">in</span> pipeline[:-<span class="number">1</span>]]</span><br><span class="line">    app = loader.get_app(pipeline[-<span class="number">1</span>])</span><br><span class="line">    filters.reverse()</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">filter</span> <span class="keyword">in</span> filters:</span><br><span class="line">        app = <span class="built_in">filter</span>(app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pipeline_factory</span>(<span class="params">loader, global_conf, **local_conf</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A paste pipeline replica that keys off of auth_strategy.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    pipeline = local_conf[CONF.auth_strategy]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> CONF.api_rate_limit:</span><br><span class="line">        limit_name = CONF.auth_strategy + <span class="string">&#x27;_nolimit&#x27;</span></span><br><span class="line">        pipeline = local_conf.get(limit_name, pipeline)</span><br><span class="line">    pipeline = pipeline.split()</span><br><span class="line">    <span class="keyword">return</span> _load_pipeline(loader, pipeline)</span><br></pre></td></tr></table></figure>
<p>这一段的逻辑也不难理解，pipeline实现了加载配置文件中的所有filter并将app作为参数逐层传入filter中。跳过filter中的内容，下一步直接跳入到最后的app，看一下app是如何实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nova/api/openstack/compute/__init__.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APIRouterV21</span>(nova.api.openstack.APIRouterV21):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Routes requests on the OpenStack API to the appropriate controller</span></span><br><span class="line"><span class="string">    and method.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init_only=<span class="literal">None</span></span>):</span><br><span class="line">        self._loaded_extension_info = extension_info.LoadedExtensionInfo()</span><br><span class="line">        <span class="built_in">super</span>(APIRouterV21, self).__init__(init_only)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_register_extension</span>(<span class="params">self, ext</span>):</span><br><span class="line">        <span class="keyword">return</span> self.loaded_extension_info.register_extension(ext.obj)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loaded_extension_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._loaded_extension_info</span><br></pre></td></tr></table></figure>
<p>这里的实现了很少的逻辑，只加载了一个extensionInfo，主要参数由它的父类实现，继续看父类代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">APIRouterV21</span>(base_wsgi.Router):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Routes requests on the OpenStack v2.1 API to the appropriate controller</span></span><br><span class="line"><span class="string">    and method.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory</span>(<span class="params">cls, global_config, **local_config</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Simple paste factory, :class:`nova.wsgi.Router` doesn&#x27;t have one.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> cls()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init_only=<span class="literal">None</span>, v3mode=<span class="literal">False</span></span>):</span><br><span class="line">        self.api_extension_manager = stevedore.enabled.EnabledExtensionManager(</span><br><span class="line">            namespace=self.api_extension_namespace(),</span><br><span class="line">            check_func=_check_load_extension,</span><br><span class="line">            invoke_on_load=<span class="literal">True</span>,</span><br><span class="line">            invoke_kwds=&#123;<span class="string">&quot;extension_info&quot;</span>: self.loaded_extension_info&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v3mode:</span><br><span class="line">            mapper = PlainMapper()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mapper = ProjectMapper()</span><br><span class="line"></span><br><span class="line">        self.resources = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># NOTE(cyeoh) Core API support is rewritten as extensions</span></span><br><span class="line">        <span class="comment"># but conceptually still have core</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">list</span>(self.api_extension_manager):</span><br><span class="line">            <span class="comment"># NOTE(cyeoh): Stevedore raises an exception if there are</span></span><br><span class="line">            <span class="comment"># no plugins detected. I wonder if this is a bug.</span></span><br><span class="line">            self._register_resources_check_inherits(mapper)</span><br><span class="line">            self.api_extension_manager.<span class="built_in">map</span>(self._register_controllers)</span><br><span class="line"></span><br><span class="line">        missing_core_extensions = self.get_missing_core_extensions(</span><br><span class="line">            self.loaded_extension_info.get_extensions().keys())</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.init_only <span class="keyword">and</span> missing_core_extensions:</span><br><span class="line">            LOG.critical(_LC(<span class="string">&quot;Missing core API extensions: %s&quot;</span>),</span><br><span class="line">                         missing_core_extensions)</span><br><span class="line">            <span class="keyword">raise</span> exception.CoreAPIMissing(</span><br><span class="line">                missing_apis=missing_core_extensions)</span><br><span class="line"></span><br><span class="line">        LOG.info(_LI(<span class="string">&quot;Loaded extensions: %s&quot;</span>),</span><br><span class="line">                 <span class="built_in">sorted</span>(self.loaded_extension_info.get_extensions().keys()))</span><br><span class="line">        <span class="built_in">super</span>(APIRouterV21, self).__init__(mapper)</span><br></pre></td></tr></table></figure>
<p>删除了部分校验相关代码，可以看到这个类主要实现了对于mapper的初始化，并且使用stevedore加载了了一个api_extension_manager。然后使用api_extension_manager将resources注册进了mapper中。继续看他的父类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;WSGI middleware that maps incoming requests to WSGI apps.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mapper</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a router for the given routes.Mapper.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Each route in `mapper` must specify a &#x27;controller&#x27;, which is a</span></span><br><span class="line"><span class="string">        WSGI app to call.  You&#x27;ll probably want to specify an &#x27;action&#x27; as</span></span><br><span class="line"><span class="string">        well and have your controller be an object that can route</span></span><br><span class="line"><span class="string">        the request to the action-specific method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">          mapper = routes.Mapper()</span></span><br><span class="line"><span class="string">          sc = ServerController()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Explicit mapping of one route to a controller+action</span></span><br><span class="line"><span class="string">          mapper.connect(None, &#x27;/svrlist&#x27;, controller=sc, action=&#x27;list&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Actions are all implicitly defined</span></span><br><span class="line"><span class="string">          mapper.resource(&#x27;server&#x27;, &#x27;servers&#x27;, controller=sc)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Pointing to an arbitrary WSGI app.  You can specify the</span></span><br><span class="line"><span class="string">          # &#123;path_info:.*&#125; parameter so the target app can be handed just that</span></span><br><span class="line"><span class="string">          # section of the URL.</span></span><br><span class="line"><span class="string">          mapper.connect(None, &#x27;/v1.0/&#123;path_info:.*&#125;&#x27;, controller=BlogApp())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">map</span> = mapper</span><br><span class="line">        self._router = routes.middleware.RoutesMiddleware(self._dispatch,</span><br><span class="line">                                                          self.<span class="built_in">map</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @webob.dec.wsgify(<span class="params">RequestClass=Request</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, req</span>):</span><br><span class="line">        <span class="keyword">return</span> self._router</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @webob.dec.wsgify(<span class="params">RequestClass=Request</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_dispatch</span>(<span class="params">req</span>):</span><br><span class="line">        <span class="keyword">match</span> = req.environ[<span class="string">&#x27;wsgiorg.routing_args&#x27;</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">match</span>:</span><br><span class="line">            <span class="keyword">return</span> webob.exc.HTTPNotFound()</span><br><span class="line">        app = <span class="keyword">match</span>[<span class="string">&#x27;controller&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>
<p>实现了wsgi app约定的__call__方法，返回了router，rotuer的功能就是将地址路由到具体的函数中。至此一个url及其匹配的处理函数就已经被找到了，但是还有一个问题，api_extension_manager中都有些什么东西。这里用到了stevedore的动态加载功能，stevedore根据配置文件，将不同的资源初始化到不同的命名空间中，使用的过程中，指定命名空间，并加载对应的source就可以了,以server的resource为例。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nova.api.v21.extensions </span><br><span class="line">    <span class="attr">servers</span> = nova.api.openstack.compute.servers:Servers</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Servers</span>(extensions.V21APIExtensionBase):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Servers.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;Servers&quot;</span></span><br><span class="line">    alias = ALIAS</span><br><span class="line">    version = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_resources</span>(<span class="params">self</span>):</span><br><span class="line">        member_actions = &#123;<span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;disk&#x27;</span>: <span class="string">&#x27;GET&#x27;</span>&#125;</span><br><span class="line">        collection_actions = &#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;GET&#x27;</span>&#125;</span><br><span class="line">        resources = [</span><br><span class="line">            extensions.ResourceExtension(</span><br><span class="line">                ALIAS,</span><br><span class="line">                ServersController(extension_info=self.extension_info),</span><br><span class="line">                member_name=<span class="string">&#x27;server&#x27;</span>, collection_actions=collection_actions,</span><br><span class="line">                member_actions=member_actions)]</span><br><span class="line"></span><br><span class="line">        res = extensions.ResourceExtension(<span class="string">&#x27;os-get_servers_info&#x27;</span>,</span><br><span class="line">                                           GetServersInfoController())</span><br><span class="line">        resources.append(res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resources</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_controller_extensions</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>至此，nova-api的基本逻辑就基本完成了，其中仍有很多细节，需要阅读具体的代码，后续会继续整理nova其他组件的代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/06/openstack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)/" data-id="clomy24lo0003tkvt1mswbcl1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/11/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81TCP(%E4%B8%80)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2023/11/06/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%BA%8C)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/06/%E5%85%B3%E4%BA%8Emysql%E7%9A%84%E9%94%81/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/11/06/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/11/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81TCP(%E4%BA%8C)/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/11/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81TCP(%E4%B8%80)/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/11/06/openstack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>